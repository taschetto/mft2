\documentclass[12pt]{article}

\usepackage{sbc-template}

\usepackage{graphicx,url}

\usepackage{fancyvrb}
\usepackage{listings}
\lstset {
    mathescape,
    frame=none
}

\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{dsfont}

\usepackage[brazil]{babel}
\usepackage[utf8]{inputenc}
\usepackage{boxproof}

\sloppy

\title{Prova de Algorítmos}

\author{Pedro Vanzella\inst{1}, Guilherme Taschetto\inst{1}}

\address{Faculdade de Informática -- Pontifícia Universidade Católica do Rio
Grande do Sul (PUCRS) \\ Av. Ipiranga, 6681 - Porto Alegre / RS / Brasil
    \email{pedro@pedrovanzella.com, guilherme.taschetto@acad.pucrs.br}}

\begin{document}

\maketitle

\begin{abstract}
    This excercise aims to prove the validity of the invariants and Hoare
    triples for two algorithms, using induction and formal logical proofs.
\end{abstract}

\begin{resumo}
    Este exercício se propõe a provar a correção parcial de dois programas
    imperativos, usando como meios para tal indução natural e provas lógicas formais.
\end{resumo}

\section{Algoritmo 1}\label{sec:algo1}
\begin{lstlisting}
$Algoritmo\ 01\ (inteiro\ positivo\ x)$
$begin$
$variaveis\ locais$
$\ \ \ \ inteiros\ i,\ j;$
$\ \ \ \ i := 1; j := 4;$
$\ \ \ \ while\ i \neq x$
$\ \ \ \ \ \ \ \ j := j + 2 * i + 3;$
$\ \ \ \ \ \ \ \ i := i + 1$
$end$
\end{lstlisting}

Através da definição do cabeçalho do programa, podemos inferir a pré-condição da Tripla de Hoare correspondente: $(| x > 0 |)$. Ainda, através de um teste de
mesa podemos levantar hipóteses a respeito do que o programa faz e a invariante do laço.

\begin{table}[h]
\begin{tabular}{|l|l|l|l|l|l|}
\hline
$n$ & $x$ & $i$ & $j $ & $i \neq x$ & $j=(i+1)^2 \land i \leq x $ \\ \hline
$0$ & $4$ & $1$ & $4 $ & $1 \neq 4$ & $4=(1+1)^2 \land 1 \leq 4 $ \\ \hline
$1$ & $4$ & $2$ & $9 $ & $2 \neq 4$ & $9=(2+1)^2 \land 2 \leq 4 $ \\ \hline
$2$ & $4$ & $3$ & $16$ & $3 \neq 4$ & $16=(3+1)^2 \land 3 \leq 4$ \\ \hline
$3$ & $4$ & $4$ & $25$ & $4 = 4   $ & $25=(4+1)^2 \land 4 \leq 4$ \\ \hline
$-$ & $4$ & $4$ & $25$ & $-       $ & $25=(4+1)^2 \land 4 \leq 4$ \\ \hline
\end{tabular}
\end{table}

Analisando a tabela gerada, fica evidente que o programa tem, como objetivo, realizar o cálculo de $(x+1)^2$ e armazenar o resultado na variável $j$. Disto podemos concluir que a pós-condição
da Tripla de Hoare é $(| j = (x+1)^2 |)$. Além disto, encontramos um bom candidato para a invariante do laço: $j=(i+1)^2 \land i \leq x $. Para ter certeza que a
invariante é válida, é necessário realizar a prova formal da mesma.

\subsection{Tripla de Hoare}

\begin{lstlisting}
$(| x > 0 |)$
$i := 1; j := 4;$
$while\ i \neq x$
$\ \ \ \ j := j + 2 * i + 3;$
$\ \ \ \ i := i + 1$
$(| j = (x+1)^2 |)$
\end{lstlisting}

\subsection{Prova da Invariante}\label{sec:algo1:invar}
Devemos provar que a invariante permanece válida durante a execução do laço, não importando o número de iterações, Ou seja, devemos provar que:
\[\forall n:\mathds{N}. j_n = (i_n + 1)^2 \wedge i_n \leq x\]

Aplicando o teorema da distributividade do operador $\forall$\footnote{$\forall x.P(x) \land Q(x) = \forall x.P(x) \land \forall x.Q(x)$},
podemos dividir a prova da invariante em duas partes: $\forall n:\mathds{N}. j_n = (i_n + 1)^2$ e $\forall n:\mathds{N}. i_n \leq x$.

\subsubsection{Prova da primeira proposição}

Queremos provar que $\forall n:\mathds{N}. j_n = (i_n + 1)^2$. A proposição pode ser reescrita da forma:
\[P(k) \triangleq j_k = (i_k + 1)^2\]

\paragraph{Caso base} Precisamos provar que $P(0) \triangleq j_0 = (i_0 + 1)^2$
Veja que:
\begin{proofbox}
  \:(i_0 + 1)^2 = (1 + 1)^2   \= i:=1   \\
  \:= 4                       \= arit   \\
  \:= j_0                     \= j:=4   \\
\end{proofbox}

\paragraph{Caso indutivo} Assumimos $j_k = (i_k + 1)^2$ como Hipótese de Indução ($HI$). Logo, precisamos provar que: \[P(k+1) \triangleq j_{k+1} = (i_{k+1} +1)^2\]
Agora, veja que:
\begin{proofbox}
  \:j_{k+1} = j_k + 2*i_k + 3 \= j:=j+2*i+3 \\
  \:= j_k + i_k + i_k + 3     \= arit   \\
  \:= j_k + i_k + i_k + 1 + 2 \= arit   \\
  \:= j_k + i_k + i_{k+1} + 2 \= i:=i+1 \\
  \:= j_k + i_{k+1} + i_{k+1} + 1 \= i:=i+1 \\
  \:= (i_k + 1)^2 + i_{k+1} + i_{k+1} + 1 \= HI \\
  \:= i_{k+1}^2 + 2i_{k+1} + 1 \= i:=i+1 \\
  \:= (i_{k+1} + 1)^2 \= arit \\
\end{proofbox}

\subsubsection{Prova da segunda proposição}

Queremos provar que $\forall n:\mathds{N}. i_n \leq x$. A proposição pode ser reescrita da forma:
\[P(k) \triangleq i_k \leq x\]

\paragraph{Caso base} Precisamos provar que $P(0) \triangleq i_0 \leq x$
Veja que:
\begin{proofbox}
  \:x > 0     \= PRE    \\
  \:< 1       \= arit   \\
  \:\geq i_0  \= i:=1   \\
\end{proofbox}

\paragraph{Caso indutivo} Assumimos $P(k) \triangleq i_k \leq x$ como Hipótese de Indução ($HI$). Logo, precisamos provar que: \[P(k+1) \triangleq i_{k+1} \leq x\]
Agora, veja que:
\begin{proofbox}
  \:i_k \leq x \land i_k \neq x \= HI\ e\ loop \\
  sse\:i_k < x                  \= arit \\
  sse\:i_k + 1 \leq x           \= arit \\
  sse\:i_{k+1} \leq x           \= i:=i+1 \\
\end{proofbox}

\section{Conclusão}
\paragraph{}
Insira conclusão aqui.
É eeeeeasy. Tendeuquequedizê? Mecânicow.

\bibliographystyle{sbc}
\bibliography{teste}

\end{document}
